import datetime as dt
from typing import List, Optional
import sqlalchemy.orm as orm

from app.models.channel import Channel
from app.models.program import Program
from app.utils.iptv_parser_ng import Channel as XMLTVChannel, Program as XMLTVProgram
from app.services.logger import get_logger

logger = get_logger(__name__)


async def store_epg_channels(channels: List[XMLTVChannel], user_id: str, server_id: int, db: orm.Session):
    """
    Store parsed XMLTV channels and programmes in the database
    
    Args:
        channels: List of Channel objects from XMLTV parser
        user_id: User ID who owns the EPG data
        server_id: Server ID where the EPG data comes from
        db: Database session
    """
    logger.info(f"Storing EPG data for user {user_id}, server {server_id} - {len(channels)} channels")
    
    try:
        # Start transaction
        stored_channels = 0
        stored_programmes = 0
        
        for xmltv_channel in channels:
            # Check if channel already exists
            existing_channel = db.query(Channel).filter(
                Channel.user_id == user_id,
                Channel.server_id == server_id,
                Channel.xmltv_id == xmltv_channel.id
            ).first()
            
            if existing_channel:
                # Update existing channel
                existing_channel.set_display_names(xmltv_channel.display_names)
                existing_channel.set_icons(xmltv_channel.icons)
                existing_channel.set_urls(xmltv_channel.urls)
                existing_channel.date_last_updated = dt.datetime.now(dt.timezone.utc)
                
                # Remove existing programmes for this channel to avoid duplicates
                db.query(Programme).filter(Programme.channel_id == existing_channel.id).delete()
                
                db_channel = existing_channel
                logger.debug(f"Updated existing channel: {xmltv_channel.id}")
            else:
                # Create new channel
                db_channel = Channel(
                    user_id=user_id,
                    server_id=server_id,
                    xmltv_id=xmltv_channel.id
                )
                db_channel.set_display_names(xmltv_channel.display_names)
                db_channel.set_icons(xmltv_channel.icons)
                db_channel.set_urls(xmltv_channel.urls)
                
                db.add(db_channel)
                db.flush()  # Get the ID without committing
                stored_channels += 1
                logger.debug(f"Created new channel: {xmltv_channel.id}")
            
            # Store programmes for this channel
            for xmltv_programme in xmltv_channel.programmes:
                db_programme = _create_programme_from_xmltv(xmltv_programme, db_channel.id)
                db.add(db_programme)
                stored_programmes += 1
            
            if stored_programmes % 1000 == 0 and stored_programmes > 0:
                logger.debug(f"Stored {stored_programmes} programmes so far...")
        
        # Commit all changes
        db.commit()
        
        logger.info(f"EPG storage completed successfully:")
        logger.info(f"  - Channels stored/updated: {stored_channels}")
        logger.info(f"  - Total programmes stored: {stored_programmes}")
        logger.info(f"  - User: {user_id}, Server: {server_id}")
        
        return {
            "channels": stored_channels,
            "programmes": stored_programmes,
            "success": True
        }
        
    except Exception as e:
        logger.error(f"Failed to store EPG data for user {user_id}, server {server_id}: {e}")
        db.rollback()
        raise


def _create_program_from_xmltv(xmltv_program: XMLTVProgram, channel_id: int) -> Program:
    """
    Convert an XMLTV Program object to a database Program object
    
    Args:
        xmltv_program: Program object from XMLTV parser
        channel_id: Database ID of the channel this program belongs to
        
    Returns:
        Program: Database Program object ready to be stored
    """
    db_programme = Programme(
        channel_id=channel_id,
        start_time=xmltv_programme.start,
        stop_time=xmltv_programme.stop,
        pdc_start=xmltv_programme.pdc_start,
        vps_start=xmltv_programme.vps_start,
        showview=xmltv_programme.showview,
        videoplus=xmltv_programme.videoplus,
        clumpidx=xmltv_programme.clumpidx,
        date=xmltv_programme.date,
        new=xmltv_programme.new
    )
    
    # Set JSON fields using the helper methods
    db_programme.set_titles(xmltv_programme.titles)
    db_programme.set_json_field('sub_titles', xmltv_programme.sub_titles)
    db_programme.set_descriptions(xmltv_programme.descriptions)
    db_programme.set_credits(xmltv_programme.credits)
    db_programme.set_categories(xmltv_programme.categories)
    db_programme.set_json_field('keywords', xmltv_programme.keywords)
    db_programme.set_json_field('language', xmltv_programme.language)
    db_programme.set_json_field('orig_language', xmltv_programme.orig_language)
    db_programme.set_json_field('length', xmltv_programme.length)
    db_programme.set_json_field('icons', xmltv_programme.icons)
    db_programme.set_json_field('urls', xmltv_programme.urls)
    db_programme.set_json_field('countries', xmltv_programme.countries)
    db_programme.set_json_field('episode_nums', xmltv_programme.episode_nums)
    db_programme.set_json_field('video', xmltv_programme.video)
    db_programme.set_json_field('audio', xmltv_programme.audio)
    db_programme.set_json_field('previously_shown', xmltv_programme.previously_shown)
    db_programme.set_json_field('premiere', xmltv_programme.premiere)
    db_programme.set_json_field('last_chance', xmltv_programme.last_chance)
    db_programme.set_json_field('subtitles', xmltv_programme.subtitles)
    db_programme.set_json_field('ratings', xmltv_programme.ratings)
    db_programme.set_json_field('star_ratings', xmltv_programme.star_ratings)
    db_programme.set_json_field('reviews', xmltv_programme.reviews)
    db_programme.set_json_field('images', xmltv_programme.images)
    
    return db_programme


async def get_channel_by_xmltv_id(user_id: str, server_id: int, xmltv_id: str, db: orm.Session) -> Optional[Channel]:
    """
    Get a channel by its XMLTV ID for a specific user and server
    
    Args:
        user_id: User ID
        server_id: Server ID
        xmltv_id: XMLTV channel ID
        db: Database session
        
    Returns:
        Channel object or None if not found
    """
    return db.query(Channel).filter(
        Channel.user_id == user_id,
        Channel.server_id == server_id,
        Channel.xmltv_id == xmltv_id
    ).first()


async def get_channels_for_user_server(user_id: str, server_id: int, db: orm.Session) -> List[Channel]:
    """
    Get all channels for a specific user and server
    
    Args:
        user_id: User ID
        server_id: Server ID
        db: Database session
        
    Returns:
        List of Channel objects
    """
    return db.query(Channel).filter(
        Channel.user_id == user_id,
        Channel.server_id == server_id
    ).all()


async def get_programmes_for_channel(channel_id: int, db: orm.Session, start_time: Optional[str] = None, 
                                   end_time: Optional[str] = None) -> List[Programme]:
    """
    Get programmes for a specific channel, optionally filtered by time range
    
    Args:
        channel_id: Database channel ID
        start_time: Optional start time filter (XMLTV format)
        end_time: Optional end time filter (XMLTV format)
        db: Database session
        
    Returns:
        List of Programme objects
    """
    query = db.query(Programme).filter(Programme.channel_id == channel_id)
    
    if start_time:
        query = query.filter(Programme.start_time >= start_time)
    
    if end_time:
        query = query.filter(Programme.start_time <= end_time)
    
    return query.order_by(Programme.start_time).all()


async def get_current_and_next_programmes(channel_id: int, current_time: str, db: orm.Session) -> dict:
    """
    Get current and next programmes for a channel based on the given time
    
    Args:
        channel_id: Database channel ID
        current_time: Current time in XMLTV format
        db: Database session
        
    Returns:
        Dict with 'current' and 'next' programme objects
    """
    # Get current programme (started before current_time, ends after current_time)
    current_programme = db.query(Programme).filter(
        Programme.channel_id == channel_id,
        Programme.start_time <= current_time,
        Programme.stop_time > current_time
    ).first()
    
    # Get next programme (starts after current time)
    next_programme = db.query(Programme).filter(
        Programme.channel_id == channel_id,
        Programme.start_time > current_time
    ).order_by(Programme.start_time).first()
    
    return {
        "current": current_programme,
        "next": next_programme
    }


async def delete_epg_data_for_user_server(user_id: str, server_id: int, db: orm.Session):
    """
    Delete all EPG data (channels and programmes) for a specific user and server
    
    Args:
        user_id: User ID
        server_id: Server ID
        db: Database session
    """
    try:
        # Get all channels for this user/server
        channels = db.query(Channel).filter(
            Channel.user_id == user_id,
            Channel.server_id == server_id
        ).all()
        
        channel_ids = [channel.id for channel in channels]
        
        if channel_ids:
            # Delete programmes first (due to foreign key constraint)
            programmes_deleted = db.query(Programme).filter(
                Programme.channel_id.in_(channel_ids)
            ).delete(synchronize_session=False)
            
            # Delete channels
            channels_deleted = db.query(Channel).filter(
                Channel.user_id == user_id,
                Channel.server_id == server_id
            ).delete(synchronize_session=False)
            
            db.commit()
            
            logger.info(f"Deleted EPG data for user {user_id}, server {server_id}: "
                       f"{channels_deleted} channels, {programmes_deleted} programmes")
        else:
            logger.info(f"No EPG data found to delete for user {user_id}, server {server_id}")
            
    except Exception as e:
        logger.error(f"Failed to delete EPG data for user {user_id}, server {server_id}: {e}")
        db.rollback()
        raise